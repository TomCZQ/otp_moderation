import { __rest } from "tslib";
import axios from 'axios';
import axiosRetry from 'axios-retry';
import { createEndpoints } from './endpoints';
import { Platform, Region } from './enums';
import { RiotRateLimiter } from './rate-limiter';
const regionScopedPathPrefix = ['/riot', '/lol/match/v5'];
// type-safe Object.keys
function keys(obj) {
    return Object.keys(obj);
}
export class RiotClient {
    constructor(_a) {
        var { auth, platform, region } = _a, limiterConfig = __rest(_a, ["auth", "platform", "region"]);
        this.axiosInstance = axios.create();
        this.axiosInstance.defaults.headers.common['X-Riot-Token'] = auth;
        this.limiter = new RiotRateLimiter(this.axiosInstance, limiterConfig);
        this.endpoints = createEndpoints(this.limiter);
        this.platform = platform;
        this.region = region;
        axiosRetry(this.axiosInstance, {
            retryCondition(err) {
                var _a, _b, _c;
                const errCodes = ['ECONNRESET', 'ETIMEDOUT'];
                const statusCodes = [403, 429, 503];
                const errCode = (_a = err.code) !== null && _a !== void 0 ? _a : '';
                const statusCode = (_c = (_b = err.response) === null || _b === void 0 ? void 0 : _b.status) !== null && _c !== void 0 ? _c : 0;
                if (errCodes.includes(errCode)) {
                    return true;
                }
                if (statusCodes.includes(statusCode)) {
                    return true;
                }
                return false;
            },
            retryDelay(retryCount, err) {
                var _a;
                if (((_a = err.response) === null || _a === void 0 ? void 0 : _a.status) === 429) {
                    const retryAfter = err.response.headers['retry-after'];
                    if (retryAfter) {
                        return retryAfter * 1000;
                    }
                }
                return axiosRetry.exponentialDelay(retryCount);
            },
        });
    }
    path(path, ...urlParameters) {
        var _a, _b;
        let realPath = path;
        const pathParam = urlParameters[0];
        let originPrefix = urlParameters[1];
        if (typeof pathParam === 'object') {
            keys(pathParam).forEach((paramName) => {
                realPath = realPath.replace(`{${paramName}}`, String(pathParam[paramName]));
            });
        }
        else {
            originPrefix = pathParam;
        }
        const isRegionScoped = regionScopedPathPrefix.some((prefix) => path.startsWith(prefix));
        if (isRegionScoped) {
            originPrefix !== null && originPrefix !== void 0 ? originPrefix : (originPrefix = (_a = this.region) !== null && _a !== void 0 ? _a : Region.AMERICAS);
        }
        else {
            originPrefix !== null && originPrefix !== void 0 ? originPrefix : (originPrefix = (_b = this.platform) !== null && _b !== void 0 ? _b : Platform.NA);
        }
        return this.endpoints[path](originPrefix, encodeURI(realPath), path);
    }
}
