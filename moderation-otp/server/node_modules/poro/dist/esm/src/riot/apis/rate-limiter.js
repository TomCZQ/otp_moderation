import { __awaiter } from "tslib";
import axios from 'axios';
import { RateLimiter } from 'limiter';
import PQueue from 'p-queue';
import { Platform, Region } from './enums';
function parseRateLimitHeaders(str) {
    return str.split(',').map((rateLimit) => rateLimit.split(':').map(Number));
}
function wait(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
class SpreadRateLimiter extends RateLimiter {
    constructor(rateLimitHeader) {
        // sometimes rate limit header is empty, maybe a bug from Riot
        if (!rateLimitHeader) {
            throw new Error('Rate limit header is empty');
        }
        // Get last rate limit
        const [tokensPerInterval, intervalInSecond] = parseRateLimitHeaders(rateLimitHeader).slice(-1)[0];
        super({
            tokensPerInterval: 1,
            interval: (intervalInSecond * 1000) / tokensPerInterval,
        });
    }
}
class RegionRateLimiter {
    constructor(generalRegion, axiosInstance, config) {
        var _a;
        this.generalRegion = generalRegion;
        this.axiosInstance = axiosInstance;
        this.methodRateLimiterMap = new Map();
        this.lastRequestTime = Date.now();
        this.i = 0;
        this.debug = config.debug;
        this.queue = new PQueue({ concurrency: (_a = config.concurrency) !== null && _a !== void 0 ? _a : Infinity });
    }
    execute(realPath, path, query) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.preAppRequest();
            yield this.preMethodRequest(path);
            return this.queue
                .add(() => {
                if (this.debug) {
                    const now = Date.now();
                    // eslint-disable-next-line no-console
                    console.log(this.generalRegion, realPath, 'request', this.i++, now - this.lastRequestTime);
                    this.lastRequestTime = now;
                    // Mock request if limiter has created (that's say, the first request for each method are not mocked)
                    if (this.debug === 'mock') {
                        if (this.appRateLimiter && this.methodRateLimiterMap.get(path)) {
                            return Promise.resolve({});
                        }
                    }
                }
                const origin = `https://${this.generalRegion.toLowerCase()}.api.riotgames.com`;
                return this.axiosInstance.get(origin + realPath, {
                    params: query,
                });
            })
                .then((res) => __awaiter(this, void 0, void 0, function* () {
                yield this.postAppRequest(res);
                yield this.postMethodRequest(res, path);
                return res;
            }))
                .catch((err) => __awaiter(this, void 0, void 0, function* () {
                if (axios.isAxiosError(err) && err.response) {
                    yield this.postAppRequest(err.response);
                    yield this.postMethodRequest(err.response, path);
                }
                throw err;
            }));
        });
    }
    preAppRequest() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            // Mark the first app request
            if (this.appRateLimiter === undefined) {
                this.appRateLimiter = null;
            }
            else if (!this.appRateLimiter) {
                // Wait for the response of the first app request
                // eslint-disable-next-line no-constant-condition
                while (true) {
                    yield wait(100);
                    if (this.appRateLimiter)
                        break;
                }
            }
            yield ((_a = this.appRateLimiter) === null || _a === void 0 ? void 0 : _a.removeTokens(1));
        });
    }
    postAppRequest(res) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.appRateLimiter === null) {
                const appRateLimit = res.headers['x-app-rate-limit'];
                this.appRateLimiter = new SpreadRateLimiter(appRateLimit);
                yield this.appRateLimiter.removeTokens(1);
            }
        });
    }
    preMethodRequest(path) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            // Mark the first method request
            if (this.methodRateLimiterMap.get(path) === undefined) {
                this.methodRateLimiterMap.set(path, null);
            }
            else if (!this.methodRateLimiterMap.get(path)) {
                // Wait for the response of the first method request
                // eslint-disable-next-line no-constant-condition
                while (true) {
                    yield wait(100);
                    if (this.methodRateLimiterMap.get(path))
                        break;
                }
            }
            yield ((_a = this.methodRateLimiterMap.get(path)) === null || _a === void 0 ? void 0 : _a.removeTokens(1));
        });
    }
    postMethodRequest(res, path) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.methodRateLimiterMap.get(path) === null) {
                const methodRateLimit = res.headers['x-method-rate-limit'];
                const methodRateLimiter = new SpreadRateLimiter(methodRateLimit);
                this.methodRateLimiterMap.set(path, methodRateLimiter);
                yield methodRateLimiter.removeTokens(1);
            }
        });
    }
}
export class RiotRateLimiter {
    constructor(axiosInstance, config) {
        this.regionRateLimiterMap = new Map();
        // eslint-disable-next-line @typescript-eslint/no-extra-semi
        ;
        [...Object.values(Region), ...Object.values(Platform)].forEach((generalRegion) => {
            this.regionRateLimiterMap.set(generalRegion, new RegionRateLimiter(generalRegion, axiosInstance, config));
        });
    }
    execute(generalRegion, realPath, path, query) {
        return this.regionRateLimiterMap
            .get(generalRegion)
            .execute(realPath, path, query);
    }
}
